/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var y=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var $=Object.getOwnPropertyNames;var I=Object.prototype.hasOwnProperty;var P=(o,n)=>{for(var e in n)y(o,e,{get:n[e],enumerable:!0})},N=(o,n,e,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let s of $(n))!I.call(o,s)&&s!==e&&y(o,s,{get:()=>n[s],enumerable:!(t=T(n,s))||t.enumerable});return o};var R=o=>N(y({},"__esModule",{value:!0}),o);var k={};P(k,{default:()=>x});module.exports=R(k);var v=require("obsidian");var b={ignoreRegexes:["^_","^Untitled$","^Untitled \\d+$"],timeoutSeconds:5,caseSensitive:!1,autoCreateFrontmatter:!0,includeFolders:[],excludeFolders:[],fileExtensions:["md"],trackFolderRenames:!1};var c=require("obsidian"),h=class extends c.PluginSettingTab{constructor(e,t){super(e,t);this.plugin=t}display(){let{containerEl:e}=this;e.empty(),new c.Setting(e).setName("Ignore regex patterns").setDesc("Comma-separated regex patterns for filenames or immediate parent folder names to ignore (e.g., ^_ for underscore prefixes, ^Untitled$ for Untitled). Leave empty to disable.").addText(t=>t.setPlaceholder("^_,^Untitled$,^Untitled \\d+$").setValue(this.plugin.settings.ignoreRegexes.join(",")).onChange(async s=>{this.plugin.settings.ignoreRegexes=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()})),new c.Setting(e).setName("Timeout seconds").setDesc("Time in seconds the name must be stable before adding aliases.").addSlider(t=>t.setLimits(1,20,1).setValue(this.plugin.settings.timeoutSeconds).setDynamicTooltip().onChange(async s=>{this.plugin.settings.timeoutSeconds=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("Case sensitive uniqueness").setDesc('If enabled, treat "Note" and "note" as different aliases.').addToggle(t=>t.setValue(this.plugin.settings.caseSensitive).onChange(async s=>{this.plugin.settings.caseSensitive=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("Auto-create properties").setDesc("Automatically create properties with aliases if missing.").addToggle(t=>t.setValue(this.plugin.settings.autoCreateFrontmatter).onChange(async s=>{this.plugin.settings.autoCreateFrontmatter=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("Track folder renames").setDesc("If enabled, store old immediate parent folder names as aliases when parent folders are renamed.").addToggle(t=>t.setValue(this.plugin.settings.trackFolderRenames).onChange(async s=>{this.plugin.settings.trackFolderRenames=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("File extensions").setDesc("Comma-separated list of file extensions to track, e.g., md,mdx").addText(t=>t.setValue(this.plugin.settings.fileExtensions.join(",")).onChange(async s=>{this.plugin.settings.fileExtensions=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()})),new c.Setting(e).setName("Include folders").setDesc("Comma-separated list of folder paths to include (empty for all). Use {vault} or {root} to include only files directly in the vault root (no subfolders).").addText(t=>t.setValue(this.plugin.settings.includeFolders.join(",")).onChange(async s=>{this.plugin.settings.includeFolders=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()})),new c.Setting(e).setName("Exclude folders").setDesc("Comma-separated list of folder paths to exclude. Use {vault} or {root} to exclude files directly in the vault root (no subfolders).").addText(t=>t.setValue(this.plugin.settings.excludeFolders.join(",")).onChange(async s=>{this.plugin.settings.excludeFolders=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()}))}};var S=class{constructor(n,e){this.app=n;this.settings=e}async processAliases(n,e){let t=this.app.vault.getFileByPath(n);if(!t)return;let s=[];for(let a of this.settings.ignoreRegexes)try{s.push(new RegExp(a))}catch(r){console.error(`Invalid ignore regex: ${a}`,r)}let i=[],m=t.basename,f=m.toLowerCase();for(let a of e){if(s.some(l=>l.test(a))){console.log(`Skipping alias "${a}" for file "${n}" due to matching ignore regex`);continue}let r=a.toLowerCase();if(this.settings.caseSensitive&&a===m||!this.settings.caseSensitive&&r===f){console.log(`Skipping alias "${a}" for file "${n}": matches current basename`);continue}i.push(a)}i.length!==0&&await this.app.fileManager.processFrontMatter(t,a=>{let r=a.aliases;if(!Array.isArray(r)){if(!this.settings.autoCreateFrontmatter)return;r=[],a.aliases=r}let l=new Set(this.settings.caseSensitive?r:r.map(d=>d.toLowerCase()));for(let d of i){let p=this.settings.caseSensitive?d:d.toLowerCase();l.has(p)||(r.push(d),l.add(p),console.log(`Added alias "${d}" for file "${n}"`))}})}};function A(o){return(o.split("/").pop()||"").replace(/\.[^/.]+$/,"")}function F(o){let n=o.split("/");return n.pop(),n.pop()||""}var x=class extends v.Plugin{constructor(){super(...arguments);this.debounceMap=new Map}async onload(){await this.loadSettings(),this.aliasProcessor=new S(this.app,this.settings),this.addSettingTab(new h(this.app,this)),this.registerEvent(this.app.vault.on("rename",this.handleRename.bind(this)))}onunload(){for(let e of this.debounceMap.values())e.timeoutId!==null&&clearTimeout(e.timeoutId);this.debounceMap.clear()}async loadSettings(){this.settings=Object.assign({},b,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}isPathInFolder(e,t){if(t.includes("{vault}")||t.includes("{root}")){let s=t.replace(/\{vault\}|\{root\}/g,"");if(s===""||s==="/"){let i=!e.includes("/");return console.log(`Checking vault root for "${e}": ${i} (vault root only)`),i}return e.startsWith(s+"/")||e===s}return e.startsWith(t+"/")||e===t}async handleRename(e,t){if(!(e instanceof v.TFile)||!this.settings.fileExtensions.includes(e.extension))return;let s=A(t),i=e.basename,m=F(t),f=F(e.path),a=this.settings.caseSensitive?s!==i:s.toLowerCase()!==i.toLowerCase(),r=m!==f&&!a;if(!a&&!r){console.log(`Skipping rename for "${t}" to "${e.path}": no significant change`);return}let l=e.path;if(a){if(this.settings.includeFolders.length>0&&!this.settings.includeFolders.some(g=>this.isPathInFolder(l,g))){console.log(`Skipping filename rename for "${l}": not in included folders`);return}if(this.settings.excludeFolders.some(g=>this.isPathInFolder(l,g))){console.log(`Skipping filename rename for "${l}": in excluded folders`);return}}let d=[];for(let g of this.settings.ignoreRegexes)try{d.push(new RegExp(g))}catch(C){console.error(`Invalid ignore regex: ${g}`,C)}let p=null;if(a){if(d.some(g=>g.test(s)||g.test(i))){console.log(`Skipping filename rename from "${s}" to "${i}" for file "${l}" due to matching ignore regex`);return}p=s}else if(r&&this.settings.trackFolderRenames){if(m===""||f===""){console.log(`Skipping folder rename for "${l}": root-level file`);return}if(d.some(g=>g.test(m)||g.test(f))){console.log(`Skipping folder rename from "${m}" to "${f}" for file "${l}" due to matching ignore regex`);return}p=m}if(!p)return;let u,w=this.debounceMap.get(t);w?(u=w,this.debounceMap.delete(t),u.currentPath=e.path):u={queue:new Set,timeoutId:null,currentPath:e.path},u.queue.add(p),u.timeoutId!==null&&clearTimeout(u.timeoutId),u.timeoutId=setTimeout(()=>{this.aliasProcessor.processAliases(u.currentPath,u.queue),this.debounceMap.delete(u.currentPath)},this.settings.timeoutSeconds*1e3),this.debounceMap.set(e.path,u)}};
