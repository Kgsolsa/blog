/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var F=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var I=Object.prototype.hasOwnProperty;var P=(o,n)=>{for(var e in n)F(o,e,{get:n[e],enumerable:!0})},R=(o,n,e,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let s of k(n))!I.call(o,s)&&s!==e&&F(o,s,{get:()=>n[s],enumerable:!(t=T(n,s))||t.enumerable});return o};var E=o=>R(F({},"__esModule",{value:!0}),o);var N={};P(N,{default:()=>v});module.exports=E(N);var y=require("obsidian");var C={ignoreRegexes:["^_","^Untitled$","^Untitled \\d+$"],timeoutSeconds:5,caseSensitive:!1,autoCreateFrontmatter:!0,includeFolders:[],excludeFolders:[],fileExtensions:["md"],trackFolderRenames:""};var c=require("obsidian"),x=class extends c.PluginSettingTab{constructor(e,t){super(e,t);this.plugin=t}display(){let{containerEl:e}=this;e.empty(),new c.Setting(e).setName("Ignore regex patterns").setDesc("Comma-separated regex patterns for file names or immediate parent folder names to ignore (e.g., ^_ for underscore prefixes, ^Untitled$ for Untitled). Leave empty to disable.").addText(t=>t.setPlaceholder("^_,^Untitled$,^Untitled \\d+$").setValue(this.plugin.settings.ignoreRegexes.join(",")).onChange(async s=>{this.plugin.settings.ignoreRegexes=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()})),new c.Setting(e).setName("Timeout seconds").setDesc("Time in seconds the name must be stable before adding aliases.").addSlider(t=>t.setLimits(1,20,1).setValue(this.plugin.settings.timeoutSeconds).setDynamicTooltip().onChange(async s=>{this.plugin.settings.timeoutSeconds=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("Case sensitive uniqueness").setDesc('If enabled, treat "Note" and "note" as different aliases.').addToggle(t=>t.setValue(this.plugin.settings.caseSensitive).onChange(async s=>{this.plugin.settings.caseSensitive=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("Auto-create properties").setDesc("Automatically create properties with aliases if missing.").addToggle(t=>t.setValue(this.plugin.settings.autoCreateFrontmatter).onChange(async s=>{this.plugin.settings.autoCreateFrontmatter=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("Track folder renames for specific file name").setDesc("If a markdown file matches this file name, store old immediate parent folder names as aliases when parent folders are renamed.").addText(t=>t.setPlaceholder("index").setValue(this.plugin.settings.trackFolderRenames).onChange(async s=>{this.plugin.settings.trackFolderRenames=s,await this.plugin.saveSettings()})),new c.Setting(e).setName("File extensions").setDesc("Comma-separated list of file extensions to track, e.g., md,mdx").addText(t=>t.setValue(this.plugin.settings.fileExtensions.join(",")).onChange(async s=>{this.plugin.settings.fileExtensions=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()})),new c.Setting(e).setName("Include folders").setDesc("Comma-separated list of folder paths to include (empty for all). Use {vault} or {root} to include only files directly in the vault root (no subfolders).").addText(t=>t.setValue(this.plugin.settings.includeFolders.join(",")).onChange(async s=>{this.plugin.settings.includeFolders=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()})),new c.Setting(e).setName("Exclude folders").setDesc("Comma-separated list of folder paths to exclude. Use {vault} or {root} to exclude files directly in the vault root (no subfolders).").addText(t=>t.setValue(this.plugin.settings.excludeFolders.join(",")).onChange(async s=>{this.plugin.settings.excludeFolders=s.split(",").map(i=>i.trim()).filter(i=>i),await this.plugin.saveSettings()}))}};var S=class{constructor(n,e){this.app=n;this.settings=e}async processAliases(n,e){let t=this.app.vault.getFileByPath(n);if(!t)return;let s=[];for(let a of this.settings.ignoreRegexes)try{s.push(new RegExp(a))}catch(r){console.error(`Invalid ignore regex: ${a}`,r)}let i=[],d=t.basename,f=d.toLowerCase();for(let a of e){if(s.some(l=>l.test(a))){console.log(`Skipping alias "${a}" for file "${n}" due to matching ignore regex`);continue}let r=a.toLowerCase();if(this.settings.caseSensitive&&a===d||!this.settings.caseSensitive&&r===f){console.log(`Skipping alias "${a}" for file "${n}": matches current basename`);continue}i.push(a)}i.length!==0&&await this.app.fileManager.processFrontMatter(t,a=>{let r=a.aliases;if(!Array.isArray(r)){if(!this.settings.autoCreateFrontmatter)return;r=[],a.aliases=r}let l=new Set(this.settings.caseSensitive?r:r.map(m=>m.toLowerCase()));for(let m of i){let u=this.settings.caseSensitive?m:m.toLowerCase();l.has(u)||(r.push(m),l.add(u),console.log(`Added alias "${m}" for file "${n}"`))}})}};function A(o){return(o.split("/").pop()||"").replace(/\.[^/.]+$/,"")}function w(o){let n=o.split("/");return n.pop(),n.pop()||""}var v=class extends y.Plugin{constructor(){super(...arguments);this.debounceMap=new Map}async onload(){await this.loadSettings(),this.aliasProcessor=new S(this.app,this.settings),this.addSettingTab(new x(this.app,this)),this.registerEvent(this.app.vault.on("rename",this.handleRename.bind(this)))}onunload(){for(let e of this.debounceMap.values())e.timeoutId!==0&&window.clearTimeout(e.timeoutId);this.debounceMap.clear()}async loadSettings(){this.settings=Object.assign({},C,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}isPathInFolder(e,t){if(t.includes("{vault}")||t.includes("{root}")){let s=t.replace(/\{vault\}|\{root\}/g,"");if(s===""||s==="/"){let i=!e.includes("/");return console.log(`Checking vault root for "${e}": ${i} (vault root only)`),i}return e.startsWith(s+"/")||e===s}return e.startsWith(t+"/")||e===t}async handleRename(e,t){if(!(e instanceof y.TFile)||!this.settings.fileExtensions.includes(e.extension))return;let s=A(t),i=e.basename,d=w(t),f=w(e.path),a=this.settings.caseSensitive?s!==i:s.toLowerCase()!==i.toLowerCase(),r=d!==f&&!a;if(!a&&!r){console.log(`Skipping rename for "${t}" to "${e.path}": no significant change`);return}let l=e.path;if(a){if(this.settings.includeFolders.length>0&&!this.settings.includeFolders.some(g=>this.isPathInFolder(l,g))){console.log(`Skipping file name rename for "${l}": not in included folders`);return}if(this.settings.excludeFolders.some(g=>this.isPathInFolder(l,g))){console.log(`Skipping file name rename for "${l}": in excluded folders`);return}}let m=[];for(let g of this.settings.ignoreRegexes)try{m.push(new RegExp(g))}catch(b){console.error(`Invalid ignore regex: ${g}`,b)}let u=null;if(a){if(m.some(g=>g.test(s)||g.test(i))){console.log(`Skipping file name rename from "${s}" to "${i}" for file "${l}" due to matching ignore regex`);return}u=s}else if(r&&this.settings.trackFolderRenames&&this.settings.trackFolderRenames.trim()!==""){let g=e.basename;if(!(this.settings.caseSensitive?g===this.settings.trackFolderRenames:g.toLowerCase()===this.settings.trackFolderRenames.toLowerCase())){console.log(`Skipping folder rename for "${l}": file name "${g}" does not match tracked file name "${this.settings.trackFolderRenames}"`);return}if(d===""||f===""){console.log(`Skipping folder rename for "${l}": root-level file`);return}if(m.some($=>$.test(d)||$.test(f))){console.log(`Skipping folder rename from "${d}" to "${f}" for file "${l}" due to matching ignore regex`);return}u=d}if(!u)return;let p=this.debounceMap.get(e.path);p||(p=this.debounceMap.get(t),p&&this.debounceMap.delete(t)),p&&(p.timeoutId!==0&&window.clearTimeout(p.timeoutId),u=Array.from(p.queue)[0]);let h={queue:new Set([u]),timeoutId:0,currentPath:e.path};h.timeoutId=window.setTimeout(()=>{this.aliasProcessor.processAliases(h.currentPath,h.queue),this.debounceMap.delete(h.currentPath)},this.settings.timeoutSeconds*1e3),this.debounceMap.set(e.path,h)}};
