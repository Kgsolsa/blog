---
import type { Post, LinkedMention } from '@/types';
import { findLinkedMentions } from '@/utils/wikilinks';
import { getCollection } from 'astro:content';
import Icon from './Icon.astro';

export interface Props {
  currentSlug: string;
}

const { currentSlug } = Astro.props;

// Get all posts and pages to find linked mentions
const posts = await getCollection('posts');
const pages = await getCollection('pages');
const linkedMentions = findLinkedMentions(posts as any[], currentSlug, posts as any[], pages as any[]);

// Function to process links in excerpt text
function processExcerptLinks(text: string, targetSlug: string): string {
  // First, process wikilinks - keep brackets but bold only the relevant link
  text = text.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (match, link, display) => {
    // Parse anchor if present
    const anchorIndex = link.indexOf('#');
    const baseLink = anchorIndex === -1 ? link : link.substring(0, anchorIndex);
    
    console.log('Detailed anchor parsing:', {
      link,
      anchorIndex,
      baseLink,
      'baseLink.length': baseLink.length,
      'link.length': link.length
    });
    
    // Process the link to get the slug for comparison
    let linkSlug = baseLink.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
    
    // Handle posts/path format
    if (baseLink.startsWith('posts/')) {
      const postPath = baseLink.replace('posts/', '');
      // Use content-aware logic to determine if we should remove /index
      const targetPost = posts.find(p => p.slug === postPath.replace('/index', ''));
      const shouldRemove = targetPost ? targetPost.id.endsWith('/index') : false;
      const cleanPath = shouldRemove && postPath.endsWith('/index') ? postPath.replace('/index', '') : postPath;
      linkSlug = cleanPath.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
    }
    
    const isRelevantLink = linkSlug === targetSlug;
    
    if (isRelevantLink) {
      // For relevant links, create the proper wikilink format and bold it
      // If there's a display override, use [[display]], otherwise use [[link]]
      const properFormat = display ? `[[${display}]]` : `[[${link}]]`;
      return `<strong class="text-primary-800 dark:text-primary-200">${properFormat}</strong>`;
    }
    
    // Return the original match for non-relevant links
    return match;
  });
  
  // Then, process standard markdown links - convert to wikilink format and bold only the relevant link
  text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, displayText, url) => {
    // Parse anchor if present
    const anchorIndex = url.indexOf('#');
    const baseUrl = anchorIndex === -1 ? url : url.substring(0, anchorIndex);
    
    // Extract the link text from URL to check if it matches target
    let linkText: string | null = null;
    if (baseUrl.endsWith('.md')) {
      linkText = baseUrl.replace(/\.md$/, '');
      // Use content-aware logic to determine if we should remove /index
      if (linkText) {
        const targetPost = posts.find(p => p.slug === linkText!.replace('/index', ''));
        const shouldRemove = targetPost ? targetPost.id.endsWith('/index') : false;
        if (shouldRemove && linkText!.endsWith('/index')) {
          linkText = linkText!.replace('/index', '');
        }
      }
    } else if (baseUrl.startsWith('/posts/')) {
      linkText = baseUrl.replace('/posts/', '');
    } else if (!baseUrl.includes('/')) {
      linkText = baseUrl;
    }
    
    if (linkText) {
      const linkSlug = linkText.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
      const isRelevantLink = linkSlug === targetSlug;
      
      // Convert markdown link to wikilink format: [Display](url) â†’ [[Display]]
      const wikilinkFormat = `[[${displayText}]]`;
      
      if (isRelevantLink) {
        // Bold the wikilink format for the relevant link
        return `<strong class="text-primary-800 dark:text-primary-200">${wikilinkFormat}</strong>`;
      } else {
        // Keep as wikilink format but not bold
        return wikilinkFormat;
      }
    }
    
    // If we can't extract link text, keep the original markdown format
    return match;
  });
  
  return text;
}
---

{linkedMentions.length > 0 && (
  <section class="mt-12 pt-8 border-t border-primary-200 dark:border-primary-700">
    <h2 class="text-xl font-semibold text-primary-900 dark:text-primary-50 mb-6 flex items-center">
      <Icon name="link-2" class="w-5 h-5 mr-2" />
      Linked Mentions
      <span class="ml-2 text-sm font-normal text-primary-500 dark:text-primary-400">
        ({linkedMentions.length})
      </span>
    </h2>
    
    <div class="space-y-4">
      {linkedMentions.filter(mention => mention !== null).map(mention => (
        <article class="p-4 bg-primary-50 dark:bg-primary-800/30 rounded-lg border border-primary-200 dark:border-primary-700 hover:border-primary-300 dark:hover:border-primary-600 transition-colors">
          <h3 class="font-medium text-primary-900 dark:text-primary-50 mb-2">
            <a 
              href={`/posts/${mention.slug}`}
              class="hover:text-highlight-600 dark:hover:text-highlight-400 transition-colors"
            >
              {mention.title}
            </a>
          </h3>
          
          {mention.excerpt && (
            <p 
              class="text-sm text-primary-600 dark:text-primary-300 leading-relaxed"
              set:html={`...${processExcerptLinks(mention.excerpt, currentSlug)}...`}
            />
          )}
          
          <div class="mt-3 flex items-center text-xs text-primary-500 dark:text-primary-400">
            <Icon name="arrow-right" class="w-3 h-3 mr-1" />
            <span>Referenced in this post</span>
          </div>
        </article>
      ))}
    </div>
  </section>
)}

<style>
  /* Enhanced styling for linked mentions */
  .linked-mention-item {
    position: relative;
  }
  
  .linked-mention-item::before {
    content: '';
    position: absolute;
    left: -1rem;
    top: 0;
    bottom: 0;
    width: 3px;
    background: linear-gradient(to bottom, rgb(14 165 233), rgb(59 130 246));
    border-radius: 2px;
    opacity: 0.3;
  }
  
  .linked-mention-item:hover::before {
    opacity: 1;
  }
</style>
