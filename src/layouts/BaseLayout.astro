
---
import { ViewTransitions } from 'astro:transitions';
import { siteConfig } from '@/config';
import type { SEOData } from '@/types';
import Header from '@/components/Header.astro';
import Footer from '@/components/Footer.astro';
import CommandPalette from '@/components/CommandPalette.astro';
import ScrollToTop from '@/components/ScrollToTop.astro';
import { logger } from '@/utils/logger';
import '@/styles/global.css';

export interface Props {
  seoData: SEOData;
  bodyClass?: string;
}

const { seoData, bodyClass = '' } = Astro.props;
---

<!DOCTYPE html>
<html lang={siteConfig.language} class="scrollbar-hide">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- SEO Meta Tags -->
  <title>{seoData.title}</title>
  <meta name="description" content={seoData.description}>
  <link rel="canonical" href={seoData.canonical}>

  <!-- Robots meta tag -->  
  {seoData.noIndex && (  
  <meta name="robots" content="noindex, nofollow">  
  )}

  <!-- Open Graph -->
  <meta property="og:title" content={seoData.title}>
  <meta property="og:description" content={seoData.description}>
  <meta property="og:url" content={seoData.canonical}>
  <meta property="og:type" content={seoData.ogType}>
  <meta property="og:site_name" content={siteConfig.title}>

  {seoData.ogImage ? (
    <>
      <meta property="og:image" content={seoData.ogImage.url}>
      <meta property="og:image:alt" content={seoData.ogImage.alt}>
      <meta property="og:image:width" content={seoData.ogImage.width.toString()}>
      <meta property="og:image:height" content={seoData.ogImage.height.toString()}>
    </>
  ) : (
    <>
      <meta property="og:image" content="/open-graph.png">
      <meta property="og:image:alt" content={siteConfig.seo.defaultOgImageAlt}>
      {/* Assuming default image dimensions, adjust if known */}
      <meta property="og:image:width" content="1200">
      <meta property="og:image:height" content="630">
    </>
  )}

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content={seoData.title}>
  <meta name="twitter:description" content={seoData.description}>
  {seoData.ogImage ? (
    <>
      <meta name="twitter:image" content={seoData.ogImage.url}>
      <meta name="twitter:image:alt" content={seoData.ogImage.alt}>
    </>
  ) : (
    <>
      <meta name="twitter:image" content="/open-graph.png">
      <meta name="twitter:image:alt" content={siteConfig.seo.defaultOgImageAlt}>
    </>
  )}


  <!-- Article specific meta tags -->
  {seoData.ogType === 'article' && (
    <>
      {seoData.publishedTime && <meta property="article:published_time" content={seoData.publishedTime}>}
      {seoData.modifiedTime && <meta property="article:modified_time" content={seoData.modifiedTime}>}
      {seoData.tags && seoData.tags.map(tag => (
        <meta property="article:tag" content={tag}>
      ))}
    </>
  )}

  <!-- Theme-aware favicons -->
    <link rel="icon" type="image/png" href="/favicon.png" />
    <link rel="icon" type="image/png" href="/favicon-light.png" media="(prefers-color-scheme: light)" />
    <link rel="icon" type="image/png" href="/favicon-dark.png" media="(prefers-color-scheme: dark)" />

  <!-- Command Palette Config for Client Script -->
  <meta name="command-palette-shortcut" content={siteConfig.commandPalette.shortcut || ''}>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css">

  <!-- Swup -->
  <script src="https://unpkg.com/swup@4"></script>

  <!-- Theme initialization script -->
  <script is:inline>
    // Initialize theme before page renders to prevent flash
    function initTheme() {
      const stored = localStorage.getItem('theme');
      const system = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      const theme = stored || system;

      document.documentElement.classList.remove('light', 'dark');
      document.documentElement.classList.add(theme);

      // Update favicon - this is now handled by media attributes on the link tags
    }

    // Initialize immediately
    initTheme();

    // View Transitions disabled - no need for astro:page-load

    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      if (!localStorage.getItem('theme')) {
        const newTheme = e.matches ? 'dark' : 'light';
        localStorage.setItem('theme', newTheme);
        initTheme();
      }
    });

    // Global theme toggle function - always available regardless of button visibility
    function toggleTheme() {
      const html = document.documentElement;
      const isDark = html.classList.contains('dark');
      const newTheme = isDark ? 'light' : 'dark';

      // Update theme
      localStorage.setItem('theme', newTheme);
      html.classList.remove('light', 'dark');
      html.classList.add(newTheme);

      // Update favicon - this is now handled by media attributes on the link tags

      // Icons are now static SVG - no re-initialization needed

      // Dispatch theme change event
      window.dispatchEvent(new CustomEvent('themechange', {
        detail: { theme: newTheme }
      }));
    }

    // Make toggle function globally accessible
    window.toggleTheme = toggleTheme;

    // Global function to restore scroll functionality
    function restoreScroll() {
      document.body.style.overflow = '';
      document.documentElement.classList.remove('force-scroll-top');
      // Force a reflow to ensure changes take effect
      document.body.offsetHeight;
    }

    // Make restoreScroll globally accessible
    window.restoreScroll = restoreScroll;
  </script>

  <!-- View Transitions - temporarily disabled to fix compiler issues -->
  <!-- <ViewTransitions /> -->

  <!-- Additional head content -->
  <slot name="head" />
  
</head>

<body class={`min-h-screen bg-white dark:bg-primary-950 text-primary-900 dark:text-primary-50 text-selection-highlight transition-colors duration-200 flex flex-col ${bodyClass}`}>
  <!-- Skip to main content -->
  <a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 bg-primary-900 text-white px-4 py-2 rounded-md z-50">
    Skip to main content
  </a>

  <!-- Header -->
  <Header />

  <!-- Main content -->
  <main id="main-content" class="container mx-auto py-8 relative flex-grow" style={`max-width: ${siteConfig.layout.contentWidth}`}>
    <div id="swup-container" class="transition-swup-fade">
      <slot />
    </div>
  </main>

  <!-- Footer -->
  <Footer />

  <!-- Command Palette -->
  {siteConfig.features.commandPalette && <CommandPalette />}

  <!-- Scroll to Top -->
  {siteConfig.features.scrollToTop && <ScrollToTop />}


  <!-- Global scripts -->
  <script>
    // Simple client-side logger
    const isDev = window.location.hostname === 'localhost';
    const logger = {
      dev: (...args: any[]) => isDev && console.log(...args),
      info: (...args: any[]) => isDev && console.info(...args),
      warn: (...args: any[]) => console.warn(...args),
      error: (...args: any[]) => console.error(...args)
    };

    // Update navigation highlighting based on current page
    function updateNavigationHighlighting(targetPath?: string) {
      const currentPath = targetPath || window.location.pathname;
      logger.dev('🔍 Navigation highlighting - Current path:', currentPath);
      
      // Target both desktop and mobile navigation links
      const navLinks = document.querySelectorAll('header nav a, #mobile-menu nav a');
      logger.dev('🔍 Found navigation links:', navLinks.length);
      
      navLinks.forEach((link) => {
        const linkPath = (link as HTMLAnchorElement).getAttribute('href');
        
        if (linkPath) {
          // Remove ALL existing classes that could conflict
          link.classList.remove('active', 'current', 'bg-highlight-100', 'dark:bg-highlight-900', 'text-highlight-600', 'dark:text-highlight-400', 'bg-highlight-50', 'dark:bg-highlight-900/20', 'text-primary-600', 'dark:text-primary-300', 'text-primary-500', 'dark:text-primary-400');
          
          // Check if this link matches the current page
          const isActive = linkPath === currentPath || 
                          (linkPath !== '/' && currentPath.startsWith(linkPath)) ||
                          (linkPath === '/' && currentPath === '/');
          
          if (isActive) {
            logger.dev('✅ Link is active:', linkPath);
            // Add appropriate active classes based on navigation style
            const isMobile = link.closest('#mobile-menu');
            
            if (isMobile) {
              // Mobile navigation active classes
              link.classList.add('text-highlight-600', 'dark:text-highlight-400', 'bg-highlight-50', 'dark:bg-highlight-900/20');
              logger.dev('✅ Added mobile active classes to:', linkPath);
            } else {
              // Desktop navigation active classes
              link.classList.add('text-highlight-600', 'dark:text-highlight-400');
              logger.dev('✅ Added desktop active classes to:', linkPath);
            }
          } else {
            // Ensure inactive state classes are applied
            const isMobile = link.closest('#mobile-menu');
            
            if (isMobile) {
              // Mobile navigation inactive classes
              link.classList.add('text-primary-600', 'dark:text-primary-300');
            } else {
              // Desktop navigation inactive classes - check if it's minimal style
              const nav = link.closest('nav');
              const isMinimal = nav && Array.from(nav.classList).some(cls => cls.includes('space-x-4'));
              
              if (isMinimal) {
                link.classList.add('text-primary-500', 'dark:text-primary-400');
              } else {
                link.classList.add('text-primary-600', 'dark:text-primary-300');
              }
            }
          }
        }
      });
    }

    // Make function globally accessible
    (window as any).updateNavigationHighlighting = updateNavigationHighlighting;
    
    // Test the function immediately
    updateNavigationHighlighting();

    // Global image preloader to prevent reloading across navigation
    class ImagePreloader {
      loadedImages: Set<string>;
      preloadedImages: Map<string, HTMLImageElement>;
      
      constructor() {
        this.loadedImages = new Set();
        this.preloadedImages = new Map();
      }

      preloadImage(src: string, priority: string = 'low'): Promise<void> {
        return new Promise((resolve, reject) => {
          if (this.loadedImages.has(src)) {
            resolve(undefined);
            return;
          }

          if (this.preloadedImages.has(src)) {
            resolve(undefined);
            return;
          }

          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.loading = priority === 'high' ? 'eager' : 'lazy';

          img.onload = () => {
            this.loadedImages.add(src);
            this.preloadedImages.set(src, img);
            resolve(undefined);
          };

          img.onerror = () => {
            reject(new Error(`Failed to load image: ${src}`));
          };

          img.src = src;
        });
      }

      preloadAllImages(): void {
        const images = document.querySelectorAll('img[src*="/_image"]');
        images.forEach((img, index) => {
          if (img instanceof HTMLImageElement) {
            const priority = index < 3 ? 'high' : 'low';
            this.preloadImage(img.src, priority).catch((error) => {
              logger.warn('Failed to preload image:', error);
            });
          }
        });
      }
    }

    // Initialize global preloader
    (window as any).imagePreloader = new ImagePreloader();

    // Initialize table wrappers for responsive tables
    function initializeTableWrappers() {
      const tables = document.querySelectorAll('.prose table');
      tables.forEach(table => {
        if (!table.parentElement?.classList.contains('table-wrapper')) {
          const wrapper = document.createElement('div');
          wrapper.className = 'table-wrapper';
          wrapper.style.cssText = 'overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 1.5rem 0; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);';
          
          table.parentNode?.insertBefore(wrapper, table);
          wrapper.appendChild(table);
          
          // Reset table margin since wrapper handles it
          (table as HTMLElement).style.margin = '0';
        }
      });
    }

    // Make initializeTableWrappers globally accessible
    (window as any).initializeTableWrappers = initializeTableWrappers;

     // Handle scroll position restoration on page refresh (backup method)
     function handleScrollPositionOnRefresh() {
       const currentUrl = window.location.href;
       const scrollKey = `scrollPosition_${currentUrl}`;
       
       logger.dev('🔍 SCROLL DEBUG - Backup restoration check for:', currentUrl);
       
       // Check if this is a page refresh by looking at performance.navigation.type
       const isPageRefresh = performance.navigation?.type === 1 || 
                            (performance.getEntriesByType && performance.getEntriesByType('navigation')[0]?.type === 'reload');
       
       // Only restore on page refresh, not on Swup navigation
       if (isPageRefresh && !window.location.hash) {
         const savedPosition = sessionStorage.getItem(scrollKey);
         
         if (savedPosition !== null) {
           const position = parseInt(savedPosition, 10);
           const currentScroll = window.pageYOffset;
           
           // Only restore if we're not already at the correct position
           if (Math.abs(currentScroll - position) > 50) {
             logger.dev('🔄 SCROLL DEBUG - Backup restoration needed:', currentScroll, '->', position);
             
             // Single attempt to restore position
             window.scrollTo(0, position);
             document.documentElement.scrollTop = position;
             document.body.scrollTop = position;
           } else {
             logger.dev('✅ SCROLL DEBUG - Position already correct:', currentScroll);
           }
         }
       }
     }

     // Handle anchors on page load/refresh
     function handleAnchorsOnLoad() {
       if (window.location.hash) {
         logger.dev('Page has anchor on load:', window.location.hash);
         setTimeout(() => {
           const hash = window.location.hash.slice(1);
           const element = document.getElementById(hash);
           if (element) {
             element.scrollIntoView({ behavior: 'smooth' });
           }
         }, 100);
       }
     }

     // Cleanup any leftover scroll-blocking state on page load
     function cleanupScrollState() {
       document.body.style.overflow = '';
       document.documentElement.classList.remove('force-scroll-top');
       logger.dev('Cleaned up scroll state on page load');
     }

     // Store scroll position on page unload/refresh
     function storeScrollPositionOnUnload() {
       const currentUrl = window.location.href;
       const scrollKey = `scrollPosition_${currentUrl}`;
       const scrollY = window.pageYOffset || document.documentElement.scrollTop;
       
      logger.dev('🔄 SCROLL DEBUG - Attempting to store scroll position:', scrollY, 'for', currentUrl);
      
      // Only store if we've scrolled down significantly
      if (scrollY > 50) {
        sessionStorage.setItem(scrollKey, scrollY.toString());
        logger.dev('✅ SCROLL DEBUG - Stored scroll position on unload:', scrollY, 'for', currentUrl);
        
        // Clean up old scroll positions to prevent sessionStorage from growing indefinitely
        // Keep only the last 10 scroll positions
        const scrollKeys = Object.keys(sessionStorage).filter(key => key.startsWith('scrollPosition_'));
        if (scrollKeys.length > 10) {
          // Sort by timestamp (if we had one) or just remove the oldest ones
          // For simplicity, we'll just remove the first few
          scrollKeys.slice(0, scrollKeys.length - 10).forEach(key => {
            sessionStorage.removeItem(key);
          });
        }
      } else {
        logger.dev('❌ SCROLL DEBUG - Scroll position too low, not storing:', scrollY);
      }
     }


     // Smooth scrolling for anchor links
     document.addEventListener('DOMContentLoaded', () => {
       // Cleanup any leftover scroll-blocking state first
       cleanupScrollState();
       
       // Enable smooth scrolling
       document.documentElement.style.scrollBehavior = 'smooth';

       // Note: Scroll position restoration is now handled after Swup initialization

       // Handle anchors on initial page load only (not on Swup transitions)
       if (!(window as any).swup) {
         handleAnchorsOnLoad();
       }

        // Initialize navigation highlighting on page load
        (window as any).updateNavigationHighlighting();

       // Preload all images on initial page load
       (window as any).imagePreloader.preloadAllImages();

       // Initialize table wrappers on initial page load
       initializeTableWrappers();

      // Global keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Command palette shortcut - dynamically read from config
        const shortcut = document.querySelector('meta[name="command-palette-shortcut"]')?.getAttribute('content');
        if (shortcut && shortcut.trim()) {
          const parts = shortcut.toLowerCase().split('+');
          const key = parts[parts.length - 1];
          const needsCtrl = parts.includes('ctrl');
          const needsMeta = parts.includes('cmd') || parts.includes('meta');

          if (((needsCtrl && e.ctrlKey) || (needsMeta && e.metaKey)) && e.key.toLowerCase() === key) {
            e.preventDefault();
            const event = new CustomEvent('openCommandPalette');
            window.dispatchEvent(event);
          }
        }
      });

      // Preload images when hovering over navigation links
      document.querySelectorAll('a[href^="/"]').forEach(link => {
        link.addEventListener('mouseenter', () => {
          // Prefetch the page and its images
          const linkUrl = link.getAttribute('href');
          if (linkUrl && linkUrl !== window.location.pathname) {
            fetch(linkUrl, { method: 'HEAD' }).catch(() => {});
          }
        });
      });
    });

    // Store scroll position on page unload/refresh
    window.addEventListener('beforeunload', storeScrollPositionOnUnload);
    window.addEventListener('pagehide', storeScrollPositionOnUnload);

  </script>

  <!-- Swup Initialization -->
  <script>
    // Simple client-side logger (redefine for this script block)
    const isDev = window.location.hostname === 'localhost';
    const logger = {
      dev: (...args: any[]) => isDev && console.log(...args),
      info: (...args: any[]) => isDev && console.info(...args),
      warn: (...args: any[]) => console.warn(...args),
      error: (...args: any[]) => console.error(...args)
    };

    // Global variable for tracking navigation type
    let isForwardNavigation = false;

    // Check if this is a page refresh - if so, don't initialize Swup
    const isPageRefresh = performance.navigation?.type === 1 || 
                         (performance.getEntriesByType && performance.getEntriesByType('navigation')[0]?.type === 'reload');
    
    if (isPageRefresh) {
      logger.dev('🔄 SCROLL DEBUG - Page refresh detected, skipping Swup initialization');
      // Let the browser handle scroll restoration naturally
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'auto';
      }
      
      // For page refreshes, restore scroll position manually since browser won't do it
      const currentUrl = window.location.href;
      const scrollKey = `scrollPosition_${currentUrl}`;
      const savedPosition = sessionStorage.getItem(scrollKey);
      
      if (savedPosition !== null && !window.location.hash) {
        const position = parseInt(savedPosition, 10);
        logger.dev('🎯 SCROLL DEBUG - Restoring scroll position for refresh:', position);
        
        // More robust restoration strategy
        let restored = false;
        const restoreScroll = () => {
          if (restored) return; // Prevent multiple restorations
          
          const currentScroll = window.pageYOffset;
          if (Math.abs(currentScroll - position) > 50) {
            window.scrollTo(0, position);
            document.documentElement.scrollTop = position;
            document.body.scrollTop = position;
            logger.dev('✅ SCROLL DEBUG - Scroll position restored from', currentScroll, 'to', position);
            restored = true;
          }
        };
        
        // Strategy 1: Immediate restoration
        restoreScroll();
        
        // Strategy 2: After DOM is ready
        document.addEventListener('DOMContentLoaded', restoreScroll);
        
        // Strategy 3: After everything loads
        window.addEventListener('load', restoreScroll);
        
        // Strategy 4: Wait for page to be stable (no layout shifts)
        let stableCount = 0;
        const checkStability = () => {
          const currentScroll = window.pageYOffset;
          if (Math.abs(currentScroll - position) > 50) {
            restoreScroll();
          }
          
          // If we're still not at the right position, keep trying
          if (Math.abs(window.pageYOffset - position) > 50) {
            stableCount++;
            if (stableCount < 10) { // Try up to 10 times
              setTimeout(checkStability, 100);
            }
          }
        };
        
        // Start stability checking after a delay
        setTimeout(checkStability, 100);
      }
    } else {
      // Initialize Swup when DOM is ready (only for normal navigation)
      document.addEventListener('DOMContentLoaded', () => {
        // Wait for Swup to be available
        if (typeof (window as any).Swup === 'undefined') {
          setTimeout(() => {
            initializeSwup();
          }, 100);
          return;
        }
        
        initializeSwup();
      });
    }

    function initializeSwup() {
      logger.info('Initializing Swup...');
      
      // Check if required container exists
      const swupContainer = document.getElementById('swup-container');
      if (!swupContainer) {
        logger.warn('Swup container not found, skipping initialization');
        return;
      }

      logger.dev('Swup container found, creating Swup instance...');

      // Explicitly set scroll restoration to manual
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
        logger.dev('history.scrollRestoration set to manual');
      }

      // Initialize Swup with basic configuration
      const swup = new (window as any).Swup({
        containers: ['#swup-container'],
        animationSelector: '[class*="transition-swup-"]',
        cache: true,
        preload: true,
        accessibility: true,
        updateHead: true,
        updateBodyClass: true,
        globalInstance: true,
        animateHistoryBrowsing: true,
        scroll: false,
        parallelRequests: false,
        timeout: 2000,
        animationDuration: 300,
        onError: (error: any) => {
          logger.warn('Swup error:', error);
          return true;
        }
      });
      
      // Handle initial page load with anchor
      if (window.location.href.includes('#')) {
        logger.dev('Initial page load with anchor detected');
        const hash = window.location.href.split('#')[1];
        logger.dev('Looking for element with ID:', hash);
        
        // Wait a bit for the page to fully load, then scroll to anchor
        setTimeout(() => {
          const element = document.getElementById(hash);
          if (element) {
            logger.dev('Found element for initial load, scrolling to it');
            element.scrollIntoView({ behavior: 'instant', block: 'start' });
          } else {
            logger.dev('Element not found for initial load');
          }
        }, 100);
      }
      
      // Override Swup's scroll behavior completely
      swup.scrollToElement = () => {};
      swup.scrollToTop = () => {};
      
      // For page refreshes, use native browser scroll restoration
      const isPageRefresh = performance.navigation?.type === 1 || 
                           (performance.getEntriesByType && performance.getEntriesByType('navigation')[0]?.type === 'reload');
      
      if (isPageRefresh) {
        logger.dev('🔄 SCROLL DEBUG - Page refresh detected, enabling native scroll restoration');
        // Re-enable native scroll restoration for page refreshes
        if ('scrollRestoration' in history) {
          history.scrollRestoration = 'auto';
        }
      }
      
      // Intercept and prevent any scroll restoration
      const originalScrollTo = window.scrollTo;
      
      (window as any).scrollTo = function(x: number | ScrollToOptions, y?: number) {
        if (typeof x === 'number' && typeof y === 'number') {
          if (isForwardNavigation && y === 0) {
            // Allow scroll to top for forward navigation
            return originalScrollTo.call(window, x, y);
          } else if (isForwardNavigation) {
            // Block any other scroll during forward navigation
            logger.dev('Blocked scroll during forward navigation:', x, y);
            return;
          }
          return originalScrollTo.call(window, x, y);
        } else {
          // Handle ScrollToOptions case
          return (originalScrollTo as any).call(window, x as ScrollToOptions);
        }
      } as typeof window.scrollTo;

      // Let Swup handle all history management natively

      // Make swup globally available
      (window as any).swup = swup;

      logger.dev('Swup instance created, setting up hooks...');

      // Setup hooks
      setupSwupHooks(swup);
      
      logger.info('Swup initialization complete!');
    }


    function setupSwupHooks(swup: any) {
      logger.dev('Setting up Swup hooks...');
      
      // Simple scroll position storage
      const scrollPositions = new Map();
      
      // Flag to track if we've already handled scroll for back navigation
      let backNavigationScrollHandled = false;
      
      // Store the target anchor for back navigation
      let pendingBackAnchor: string | null = null;
      
      // Store scroll position on link click (only for back navigation)
      swup.hooks.on('link:click', (event: any) => {
        logger.dev('Link clicked - storing scroll position for potential back navigation');
        const url = window.location.href;
        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
        scrollPositions.set(url, scrollY);
        logger.dev('Stored position for', url, 'at', scrollY);
        
        // For forward navigation, just add a class to track it
        if (!event.trigger || event.trigger.type !== 'popstate') {
          logger.dev('Forward navigation - marking for scroll to top after leaving animation');
          document.documentElement.classList.add('force-scroll-top');
        }
      });

      // Close command palette and mobile menu, set navigation flag
      swup.hooks.on('visit:start', (visit: any) => {
        logger.dev('Visit start - closing command palette and mobile menu');
        const commandPalette = document.getElementById('command-palette-overlay');
        if (commandPalette && !commandPalette.classList.contains('hidden')) {
          commandPalette.classList.add('hidden');
          
          // Ensure proper cleanup when command palette closes during navigation
          document.body.style.overflow = '';
          document.documentElement.classList.remove('force-scroll-top');
        }

        // Close mobile menu if open
        if ((window as any).closeMobileMenu) {
          (window as any).closeMobileMenu();
        }
        
        // Update navigation highlighting immediately when navigation starts
        let targetPath = window.location.pathname;
        
        // Extract pathname from visit.to.url if available
        if (visit.to?.url) {
          try {
            // If it's already a full URL, use it directly
            if (visit.to.url.startsWith('http')) {
              targetPath = new URL(visit.to.url).pathname;
            } else {
              // If it's just a pathname, use it directly
              targetPath = visit.to.url;
            }
          } catch (e) {
            targetPath = window.location.pathname;
          }
        }
        
        (window as any).updateNavigationHighlighting(targetPath);
        
        // Set flag for forward navigation
        isForwardNavigation = !visit.trigger || !visit.trigger.event || visit.trigger.event.type !== 'popstate';
        logger.dev('isForwardNavigation:', isForwardNavigation);
        
        // For forward navigation, just log - we'll handle scroll in content:replace
        if (isForwardNavigation) {
          logger.dev('Forward navigation - will scroll to top after content replacement');
        } else {
          // For back navigation, check if there's an anchor in the current URL
          // (The hash might not be in visit.to.url yet for back navigation)
          if (window.location.href.includes('#')) {
            logger.dev('Back navigation with anchor detected in visit:start - preventing scroll to top');
            // Store the anchor for later use
            const hash = window.location.href.split('#')[1];
            pendingBackAnchor = hash;
            
            // Set scroll to a high value to prevent scroll to top
            window.scrollTo(0, 999999);
            document.documentElement.scrollTop = 999999;
            document.body.scrollTop = 999999;
          }
        }
      });

      // Handle when content is about to be replaced
      swup.hooks.on('content:replace', (visit: any) => {
        // Ensure CSS is loaded before content replacement
        ensurePostCardStyles();
        // Check if this is forward navigation by looking at the trigger
        const isForwardNavigation = visit.trigger && visit.trigger.event && visit.trigger.event.type === 'click';
        
        if (isForwardNavigation && document.documentElement.classList.contains('force-scroll-top')) {
          logger.dev('Content replaced - handling scroll for forward navigation');
          
          // Check if there's an anchor in the target URL
          if (visit.to && visit.to.url && visit.to.url.includes('#')) {
            logger.dev('Forward navigation with anchor - will scroll to anchor after transition');
            // Don't scroll to top, let the anchor handling in visit:end take care of it
          } else {
            logger.dev('Forward navigation without anchor - scrolling to top');
            // Small delay to ensure the new content is ready
            setTimeout(() => {
              window.scrollTo(0, 0);
              document.documentElement.scrollTop = 0;
              document.body.scrollTop = 0;
            }, 10);
          }
        } else {
          // For back navigation, handle scroll positioning
          logger.dev('Content replaced - back navigation, handling scroll positioning');
          
          if (pendingBackAnchor) {
            logger.dev('Back navigation with pending anchor - keeping scroll position high');
            // Keep the scroll position high to prevent scroll to top
            window.scrollTo(0, 999999);
            document.documentElement.scrollTop = 999999;
            document.body.scrollTop = 999999;
          } else {
            logger.dev('Back navigation without anchor - using saved position');
            // For back navigation without anchor, use the saved position
            const savedPosition = scrollPositions.get(visit.to.url);
            if (savedPosition !== undefined) {
              logger.dev('Restoring saved position:', savedPosition);
              window.scrollTo(0, savedPosition);
              // Mark that we've handled the scroll
              backNavigationScrollHandled = true;
            } else {
              logger.dev('No saved position found, staying at top');
              window.scrollTo(0, 0);
              // Mark that we've handled the scroll
              backNavigationScrollHandled = true;
            }
          }
        }
      });

       // Handle page changes
       swup.hooks.on('visit:end', (visit: any) => {
         logger.dev('Visit end - trigger:', visit.trigger, 'to:', visit.to.url);
         logger.dev('Current URL after visit:', window.location.href);
         logger.dev('URL includes hash?', window.location.href.includes('#'));
         
         // Handle scroll behavior
         logger.dev('Trigger check:', visit.trigger, 'Event:', visit.trigger?.event);
         if (visit.trigger && visit.trigger.event && visit.trigger.event.type === 'popstate') {
           logger.dev('Back navigation detected');
           
           // Check if we have a pending anchor to scroll to
           if (pendingBackAnchor) {
             logger.dev('Back navigation with pending anchor:', pendingBackAnchor);
             const element = document.getElementById(pendingBackAnchor);
             if (element) {
               logger.dev('Found element for pending anchor, scrolling to it');
               element.scrollIntoView({ behavior: 'instant', block: 'start' });
               // Clear the pending anchor
               pendingBackAnchor = null;
               return;
             } else {
               logger.dev('Element not found for pending anchor, will retry');
               // Retry after a short delay
               setTimeout(() => {
                 if (pendingBackAnchor) {
                   const retryElement = document.getElementById(pendingBackAnchor);
                   if (retryElement) {
                     logger.dev('Found element on retry for pending anchor, scrolling to it');
                     retryElement.scrollIntoView({ behavior: 'instant', block: 'start' });
                     pendingBackAnchor = null;
                   } else {
                     logger.dev('Element still not found after retry, clearing pending anchor');
                     pendingBackAnchor = null;
                   }
                 }
               }, 100);
               return;
             }
           }
           
           // Check if we've already handled the scroll in content:replace
           if (backNavigationScrollHandled) {
             logger.dev('Scroll already handled in content:replace, skipping visit:end scroll');
             // Reset the flag for next navigation
             backNavigationScrollHandled = false;
             return;
           }
           
           // Back navigation - check the actual current URL for hash
           if (window.location.href.includes('#')) {
             // URL has anchor - scroll to it after Swup finishes
             logger.dev('URL has anchor, scrolling to it after Swup transition');
             const hash = window.location.href.split('#')[1];
             logger.dev('Looking for element with ID:', hash);
             
             setTimeout(() => {
               const element = document.getElementById(hash);
               logger.dev('Found element:', element);
               if (element) {
                 logger.dev('Scrolling to element');
                 element.scrollIntoView({ behavior: 'smooth' });
               } else {
                 logger.dev('Element not found, trying alternative approach');
                 // Try scrolling to the hash directly
                 if (hash) {
                   window.location.hash = '#' + hash;
                 }
               }
             }, 350); // Wait for Swup transition to complete
           } else {
             logger.dev('No anchor in URL, restoring saved position');
             // No anchor - restore saved position
             const savedPosition = scrollPositions.get(visit.to.url);
             if (savedPosition !== undefined && savedPosition > 0) {
               setTimeout(() => window.scrollTo(0, savedPosition), 100);
             } else {
               window.scrollTo(0, 0);
             }
           }
         } else {
           logger.dev('Forward navigation - handling scroll positioning');
           // Forward navigation - handle scroll positioning
           // Clear any stored positions for this URL
           scrollPositions.delete(visit.to.url);
           
           // Check if there's an anchor in the URL
           if (window.location.href.includes('#')) {
             logger.dev('Forward navigation with anchor - scrolling to anchor');
             const hash = window.location.hash.slice(1);
             logger.dev('Looking for element with ID:', hash);
             
             setTimeout(() => {
               const element = document.getElementById(hash);
               logger.dev('Found element:', element);
               if (element) {
                 logger.dev('Scrolling to element');
                 element.scrollIntoView({ behavior: 'smooth' });
               } else {
                 logger.dev('Element not found, trying alternative approach');
                 // Try scrolling to the hash directly
                 if (hash) {
                   window.location.hash = '#' + hash;
                 }
               }
             }, 350); // Wait for Swup transition to complete
           } else {
             logger.dev('Forward navigation without anchor - ensuring at top');
             // Ensure we're at the top
             window.scrollTo(0, 0);
             document.documentElement.scrollTop = 0;
             document.body.scrollTop = 0;
           }
           
           // Remove the force scroll class
           document.documentElement.classList.remove('force-scroll-top');
           
           // Reset the flag after a short delay
           setTimeout(() => {
             isForwardNavigation = false;
           }, 100);
         }
         
        // Reinitialize components
        (window as any).updateNavigationHighlighting();
         initializeImageGrids();
         (window as any).initializeTableWrappers();
         initializeTOC();
         initializeExternalLinks();
         initializeAnchorLinks();
         
         // Ensure PostCard styles are applied after content replacement
         ensurePostCardStyles();
       });
      
      logger.dev('Swup hooks setup complete!');
    }

    // Initialize image grids
    function initializeImageGrids() {
      const paragraphs = document.querySelectorAll('.prose p');
      
      paragraphs.forEach(p => {
        const images = p.querySelectorAll('img, picture');
        const textNodes = Array.from(p.childNodes).filter(node => 
          node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.trim() !== ''
        );
        const otherElements = Array.from(p.childNodes).filter(node => 
          node.nodeType === Node.ELEMENT_NODE && !['IMG', 'PICTURE', 'BR'].includes((node as Element).tagName)
        );
        
        if (images.length >= 2 && textNodes.length === 0 && otherElements.length === 0) {
          p.classList.remove('image-grid', 'image-grid-2', 'image-grid-3', 'image-grid-4', 'image-grid-5', 'image-grid-6');
          const gridClass = `image-grid-${Math.min(images.length, 6)}`;
          p.classList.add('image-grid', gridClass);
        }
      });
    }

    // Initialize TOC highlighting
    function initializeTOC() {
      const tocLinks = document.querySelectorAll('.toc-link');
      const headings = document.querySelectorAll('h2, h3, h4, h5, h6');
      
      if (!tocLinks.length || !headings.length) return;
      
      function highlightTOC() {
        let current = '';
        
        headings.forEach(heading => {
          const rect = heading.getBoundingClientRect();
          if (rect.top <= 100) {
            current = heading.id;
          }
        });
        
        tocLinks.forEach(link => {
          const href = link.getAttribute('href')?.slice(1);
          if (href === current) {
            link.classList.add('active');
          } else {
            link.classList.remove('active');
          }
        });
      }
      
      // Update active link on scroll
      let ticking = false;
      window.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            highlightTOC();
            ticking = false;
          });
          ticking = true;
        }
      });
      
      highlightTOC();
    }

    // Initialize external links
    function initializeExternalLinks() {
      document.querySelectorAll('a[href^="http"]').forEach(link => {
        if ((link as HTMLAnchorElement).hostname !== window.location.hostname) {
          (link as HTMLAnchorElement).target = '_blank';
        }
      });
    }

    // Initialize anchor links
    function initializeAnchorLinks() {
      document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (this: HTMLAnchorElement, e: Event) {
          e.preventDefault();
          const target = document.querySelector(this.getAttribute('href') || '');
          if (target) {
            target.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }
        });
      });
    }

    // Ensure PostCard styles are properly applied after content replacement
    function ensurePostCardStyles() {
      // Force re-application of PostCard styles by triggering a reflow
      const postCards = document.querySelectorAll('.post-card, .featured-post');
      postCards.forEach(card => {
        // Force a reflow to ensure styles are applied
        (card as HTMLElement).offsetHeight;
      });
    }

  </script>

  <!-- Additional body scripts -->
  <slot name="scripts" />
</body>
</html>