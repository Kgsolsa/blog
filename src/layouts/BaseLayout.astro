
---
import { ViewTransitions } from 'astro:transitions';
import { siteConfig } from '@/config';
import type { SEOData } from '@/types';
import Header from '@/components/Header.astro';
import Footer from '@/components/Footer.astro';
import CommandPalette from '@/components/CommandPalette.astro';
import ScrollToTop from '@/components/ScrollToTop.astro';
import { logger } from '@/utils/logger';
import '@/styles/global.css';

export interface Props {
  seoData: SEOData;
  bodyClass?: string;
}

const { seoData, bodyClass = '' } = Astro.props;
---

<!DOCTYPE html>
<html lang={siteConfig.language} class="scrollbar-hide">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- SEO Meta Tags -->
  <title>{seoData.title}</title>
  <meta name="description" content={seoData.description}>
  <link rel="canonical" href={seoData.canonical}>

  <!-- Robots meta tag -->  
  {seoData.noIndex && (  
  <meta name="robots" content="noindex, nofollow">  
  )}

  <!-- Open Graph -->
  <meta property="og:title" content={seoData.title}>
  <meta property="og:description" content={seoData.description}>
  <meta property="og:url" content={seoData.canonical}>
  <meta property="og:type" content={seoData.ogType}>
  <meta property="og:site_name" content={siteConfig.title}>

  {seoData.ogImage ? (
    <>
      <meta property="og:image" content={seoData.ogImage.url}>
      <meta property="og:image:alt" content={seoData.ogImage.alt}>
      <meta property="og:image:width" content={seoData.ogImage.width.toString()}>
      <meta property="og:image:height" content={seoData.ogImage.height.toString()}>
    </>
  ) : (
    <>
      <meta property="og:image" content="/open-graph.png">
      <meta property="og:image:alt" content={siteConfig.seo.defaultOgImageAlt}>
      {/* Assuming default image dimensions, adjust if known */}
      <meta property="og:image:width" content="1200">
      <meta property="og:image:height" content="630">
    </>
  )}

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content={seoData.title}>
  <meta name="twitter:description" content={seoData.description}>
  {seoData.ogImage ? (
    <>
      <meta name="twitter:image" content={seoData.ogImage.url}>
      <meta name="twitter:image:alt" content={seoData.ogImage.alt}>
    </>
  ) : (
    <>
      <meta name="twitter:image" content="/open-graph.png">
      <meta name="twitter:image:alt" content={siteConfig.seo.defaultOgImageAlt}>
    </>
  )}


  <!-- Article specific meta tags -->
  {seoData.ogType === 'article' && (
    <>
      {seoData.publishedTime && <meta property="article:published_time" content={seoData.publishedTime}>}
      {seoData.modifiedTime && <meta property="article:modified_time" content={seoData.modifiedTime}>}
      {seoData.tags && seoData.tags.map(tag => (
        <meta property="article:tag" content={tag}>
      ))}
    </>
  )}

  <!-- Browser theme-aware favicons -->
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-light.png" media="(prefers-color-scheme: light)" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-dark.png" media="(prefers-color-scheme: dark)" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <!-- Force favicon refresh for Firefox -->
  <script>
    // Force favicon refresh based on system theme
    function updateFaviconForTheme() {
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const faviconLink = document.querySelector('link[rel="icon"][sizes="32x32"]:not([media])');
      
      if (faviconLink && faviconLink.setAttribute) {
        const timestamp = new Date().getTime();
        if (isDark) {
          faviconLink.setAttribute('href', `/favicon-dark.png?v=${timestamp}`);
        } else {
          faviconLink.setAttribute('href', `/favicon-light.png?v=${timestamp}`);
        }
      }
    }
    
    // Update favicon on page load
    updateFaviconForTheme();
    
    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateFaviconForTheme);
  </script>

  <!-- Command Palette Config for Client Script -->
  <meta name="command-palette-shortcut" content={siteConfig.commandPalette.shortcut || ''}>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css">

  <!-- Swup handled via Astro integration -->
  
  <!-- Theme initialization script -->
  <script is:inline>
    // Initialize theme before page renders to prevent flash
    function initTheme() {
      const stored = localStorage.getItem('theme');
      const system = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      const theme = stored || system;

      document.documentElement.classList.remove('light', 'dark');
      document.documentElement.classList.add(theme);

    }

    // Initialize immediately
    initTheme();

    // View Transitions disabled - no need for astro:page-load

    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      if (!localStorage.getItem('theme')) {
        const newTheme = e.matches ? 'dark' : 'light';
        localStorage.setItem('theme', newTheme);
        initTheme();
      }
    });

    // Global theme toggle function - always available regardless of button visibility
    function toggleTheme() {
      const html = document.documentElement;
      const isDark = html.classList.contains('dark');
      const newTheme = isDark ? 'light' : 'dark';

      // Update theme
      localStorage.setItem('theme', newTheme);
      html.classList.remove('light', 'dark');
      html.classList.add(newTheme);


      // Icons are now static SVG - no re-initialization needed

      // Dispatch theme change event
      window.dispatchEvent(new CustomEvent('themechange', {
        detail: { theme: newTheme }
      }));
    }

    // Make toggle function globally accessible
    window.toggleTheme = toggleTheme;

    // Global function to restore scroll functionality
    function restoreScroll() {
      document.body.style.overflow = '';
      document.documentElement.classList.remove('force-scroll-top');
      // Force a reflow to ensure changes take effect
      document.body.offsetHeight;
    }

    // Make restoreScroll globally accessible
    window.restoreScroll = restoreScroll;

    // Collapsible callouts functionality
    function initializeCollapsibleCallouts() {
      const collapsibleCallouts = document.querySelectorAll('.callout-collapsible');
      
      collapsibleCallouts.forEach(callout => {
        const toggleButton = callout.querySelector('.callout-toggle');
        const content = callout.querySelector('.callout-content');
        
        if (!toggleButton || !content) return;
        
        // Add click handler to toggle button
        toggleButton.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const isCollapsed = callout.classList.contains('callout-collapsed');
          
          if (isCollapsed) {
            // Expand
            callout.classList.remove('callout-collapsed');
            content.style.display = '';
            toggleButton.setAttribute('aria-expanded', 'true');
          } else {
            // Collapse
            callout.classList.add('callout-collapsed');
            content.style.display = 'none';
            toggleButton.setAttribute('aria-expanded', 'false');
          }
        });
        
        // Add click handler to title for easier interaction
        const title = callout.querySelector('.callout-title');
        if (title) {
          title.addEventListener('click', (e) => {
            // Only trigger if not clicking the toggle button
            if (!e.target.closest('.callout-toggle')) {
              toggleButton.click();
            }
          });
        }
      });
    }

    // Initialize collapsible callouts when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeCollapsibleCallouts);
    } else {
      initializeCollapsibleCallouts();
    }
  </script>

  <!-- View Transitions - temporarily disabled to fix compiler issues -->
  <!-- <ViewTransitions /> -->

  <!-- Additional head content -->
  <slot name="head" />
  
</head>

<body class={`min-h-screen bg-white dark:bg-primary-950 text-primary-900 dark:text-primary-50 text-selection-highlight transition-colors duration-200 flex flex-col ${bodyClass}`}>
  <!-- Skip to main content -->
  <a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 bg-primary-900 text-white px-4 py-2 rounded-md z-50">
    Skip to main content
  </a>

  <!-- Header -->
  <Header />

  <!-- Main content -->
  <main id="main-content" class="container mx-auto relative flex-grow" style={`max-width: ${siteConfig.layout.contentWidth}`}>
    <div id="swup-container" class="transition-swup-fade">
      <slot />
    </div>
  </main>

  <!-- Footer -->
  <Footer />

  <!-- Command Palette -->
  {siteConfig.features.commandPalette && <CommandPalette />}

  <!-- Scroll to Top -->
  {siteConfig.features.scrollToTop && <ScrollToTop />}


  <!-- Global scripts -->
  <script>
    // Simple client-side logger
    const isDev = window.location.hostname === 'localhost';
    const logger = {
      dev: (...args: any[]) => isDev && console.log(...args),
      info: (...args: any[]) => isDev && console.info(...args),
      warn: (...args: any[]) => console.warn(...args),
      error: (...args: any[]) => console.error(...args)
    };

    // Update navigation highlighting based on current page
    function updateNavigationHighlighting(targetPath?: string) {
      const currentPath = targetPath || window.location.pathname;
      logger.dev('🔍 Navigation highlighting - Current path:', currentPath);
      
      // Target both desktop and mobile navigation links
      const navLinks = document.querySelectorAll('header nav a, #mobile-menu nav a');
      logger.dev('🔍 Found navigation links:', navLinks.length);
      
      navLinks.forEach((link) => {
        const linkPath = (link as HTMLAnchorElement).getAttribute('href');
        
        if (linkPath) {
          logger.dev('🔍 Checking link:', linkPath, 'against current path:', currentPath);
          // Remove ALL existing classes that could conflict
          link.classList.remove('active', 'current', 'bg-highlight-100', 'dark:bg-highlight-900', 'text-highlight-600', 'dark:text-highlight-400', 'bg-highlight-50', 'dark:bg-highlight-900/20', 'text-primary-600', 'dark:text-primary-300', 'text-primary-500', 'dark:text-primary-400');
          
          // Check if this link matches the current page
          let isActive = false;
          
          if (linkPath === currentPath) {
            // Exact match
            isActive = true;
          } else if (linkPath === '/' && currentPath === '/') {
            // Homepage exact match
            isActive = true;
          } else if (linkPath !== '/' && linkPath !== '#' && !linkPath.startsWith('http')) {
            // For internal links, check if current path starts with the link path followed by a slash
            // This handles cases like /about matching /about/ or /about/something
            isActive = currentPath.startsWith(linkPath + '/');
          }
          
          logger.dev('🔍 Link', linkPath, 'isActive:', isActive);
          
          if (isActive) {
            logger.dev('✅ Link is active:', linkPath);
            // Add appropriate active classes based on navigation style
            const isMobile = link.closest('#mobile-menu');
            
            if (isMobile) {
              // Mobile navigation active classes
              link.classList.add('text-highlight-600', 'dark:text-highlight-400', 'bg-highlight-50', 'dark:bg-highlight-900/20');
              logger.dev('✅ Added mobile active classes to:', linkPath);
            } else {
              // Desktop navigation active classes
              link.classList.add('text-highlight-600', 'dark:text-highlight-400');
              logger.dev('✅ Added desktop active classes to:', linkPath);
            }
          } else {
            // Ensure inactive state classes are applied
            const isMobile = link.closest('#mobile-menu');
            
            if (isMobile) {
              // Mobile navigation inactive classes
              link.classList.add('text-primary-600', 'dark:text-primary-300');
            } else {
              // Desktop navigation inactive classes - check if it's minimal style
              const nav = link.closest('nav');
              const isMinimal = nav && Array.from(nav.classList).some(cls => cls.includes('space-x-4'));
              
              if (isMinimal) {
                link.classList.add('text-primary-500', 'dark:text-primary-400');
              } else {
                link.classList.add('text-primary-600', 'dark:text-primary-300');
              }
            }
          }
        }
      });
    }

    // Make function globally accessible
    (window as any).updateNavigationHighlighting = updateNavigationHighlighting;
    
    // Test the function immediately
    updateNavigationHighlighting();

    // Global image preloader to prevent reloading across navigation
    class ImagePreloader {
      loadedImages: Set<string>;
      preloadedImages: Map<string, HTMLImageElement>;
      
      constructor() {
        this.loadedImages = new Set();
        this.preloadedImages = new Map();
      }

      preloadImage(src: string, priority: string = 'low'): Promise<void> {
        return new Promise((resolve, reject) => {
          if (this.loadedImages.has(src)) {
            resolve(undefined);
            return;
          }

          if (this.preloadedImages.has(src)) {
            resolve(undefined);
            return;
          }

          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.loading = priority === 'high' ? 'eager' : 'lazy';

          img.onload = () => {
            this.loadedImages.add(src);
            this.preloadedImages.set(src, img);
            resolve(undefined);
          };

          img.onerror = () => {
            reject(new Error(`Failed to load image: ${src}`));
          };

          img.src = src;
        });
      }

      preloadAllImages(): void {
        const images = document.querySelectorAll('img[src*="/_image"]');
        images.forEach((img, index) => {
          if (img instanceof HTMLImageElement) {
            const priority = index < 3 ? 'high' : 'low';
            this.preloadImage(img.src, priority).catch((error) => {
              logger.warn('Failed to preload image:', error);
            });
          }
        });
      }
    }

    // Initialize global preloader
    (window as any).imagePreloader = new ImagePreloader();

    // Initialize table wrappers for responsive tables
    function initializeTableWrappers() {
      const tables = document.querySelectorAll('.prose table');
      tables.forEach(table => {
        if (!table.parentElement?.classList.contains('table-wrapper')) {
          const wrapper = document.createElement('div');
          wrapper.className = 'table-wrapper';
          wrapper.style.cssText = 'overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 1.5rem 0; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);';
          
          table.parentNode?.insertBefore(wrapper, table);
          wrapper.appendChild(table);
          
          // Reset table margin since wrapper handles it
          (table as HTMLElement).style.margin = '0';
        }
      });
    }

    // Make initializeTableWrappers globally accessible
    (window as any).initializeTableWrappers = initializeTableWrappers;

    // Smart scroll behavior: instant for page navigation, smooth for anchors only
    function setupSwupScrollBehavior() {
      if (typeof window !== 'undefined' && (window as any).swup) {
        const swup = (window as any).swup;
        
        // Start with instant scrolling globally
        document.documentElement.style.scrollBehavior = 'auto';
        document.body.style.scrollBehavior = 'auto';
        
        // Override Swup's scroll methods to always use instant scrolling
        if (swup.scrollToElement) {
          swup.scrollToElement = () => {
            window.scrollTo(0, 0);
          };
        }
        
        if (swup.scrollToTop) {
          swup.scrollToTop = () => {
            window.scrollTo(0, 0);
          };
        }
        
        // Handle page navigation with instant scroll
        swup.hooks.on('visit:start', () => {
          // Disable smooth scrolling during page navigation
          document.documentElement.style.scrollBehavior = 'auto';
          document.body.style.scrollBehavior = 'auto';
        });
        
        swup.hooks.on('content:replace', () => {
          // This happens during the transition when content is being swapped
          window.scrollTo(0, 0);
        });
        
        // Ensure we're at top when new page is ready
        swup.hooks.on('page:view', () => {
          window.scrollTo(0, 0);
          // Update navigation highlighting after page transition
          updateNavigationHighlighting();
        });
        
        swup.hooks.on('visit:end', () => {
          // Re-enable smooth scrolling only for anchor links after page is loaded
          setTimeout(() => {
            document.documentElement.style.scrollBehavior = 'smooth';
            document.body.style.scrollBehavior = 'smooth';
            // Update navigation highlighting after page transition is complete
            updateNavigationHighlighting();
          }, 100);
        });
        
        // Handle anchor link clicks (headings, TOC) with smooth scrolling
        document.addEventListener('click', (e) => {
          const target = e.target as HTMLElement;
          const link = target.closest('a[href^="#"]');
          
          if (link) {
            const href = link.getAttribute('href');
            // Only handle anchor links that start with # and have content after #
            if (href && href.startsWith('#') && href.length > 1) {
              const targetElement = document.querySelector(href);
              if (targetElement) {
                e.preventDefault();
                // Temporarily enable smooth scrolling for this anchor click
                document.documentElement.style.scrollBehavior = 'smooth';
                document.body.style.scrollBehavior = 'smooth';
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
            }
          }
        });
      }
    }

    // Setup Swup behavior when available
    if (typeof window !== 'undefined') {
      if ((window as any).swup) {
        setupSwupScrollBehavior();
      } else {
        // Wait for Swup to be available
        document.addEventListener('swup:enable', setupSwupScrollBehavior);
      }
    }
  </script>

  <!-- Additional body scripts -->
  <slot name="scripts" />
</body>
</html>